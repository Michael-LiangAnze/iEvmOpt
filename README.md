# iEvmOpt

[TOC]

### cfg环处理

#### 前提假设

* 同一个函数内的指令的地址都是从小到大连续的
* 我们不关心函数调用关系产生的“错误的环”，因为这种错误的环我们可以在搜索路径时，可以通过符号执行或者返回地址栈解决掉。

#### 基本原理

找到某个函数的调用时的调用边和返回边，从而解析出函数的所有funcbody节点。紧接着，对函数内的所有节点，分析是否存在环即可。如果存在就把他们收缩成一个点，并标记为loop-related。在寻找所有从init到invalid的路径时，不走这些节点即可。



#### 一个简单粗暴的解决方法

找出图中所有的unconditional jump边。它们出现的原因包括：

* 函数的调用
* 函数的返回
* for、while循环结构
* 除以上原因外的其他原因

每一次函数的调用，必将伴随一次函数的返回。因此，一个函数的调用边必然和一个函数的返回边相匹配（这是我们理想的情况，实际上会有反例的，详见后面的特殊情况2）。于是我们可以假设每一条unconditional jump边(地址a---->地址b)：

* 可能是调用边。调用的起始地址为：地址a；返回地址为：a+1
* 可能是返回边。调用的起始地址为：地址b-1；返回地址为：b

这样，我们便得到了一个四元组，它可以表示为`(a,a+1,b-1,b)`。

当我们得到图中所有的四元组之后，剩下的问题，就是拿他们配对(一次调用必然引起一次返回)。做一个两层的for循环进行遍历，当我们取到两个四元组：A、B时，这样判断：

* 如果A[0] == B[2] and A[1] == B[3] ，则A是调用边，B是返回边。匹配成功
* 否则，匹配失败

匹配成功之后，如何得到一个funcbody内的所有节点？我们取出其中任意一个四元组，从调用边的终点开始做dfs，然后只走起始offset位于`[调用边指向的block的起始offset，返回边起始block的起始offset]`的节点，这样便能找到所有的funcbody节点。



#### 可能遇到的一些特殊情况

###### 1.在循环里面进行函数调用

函数代码大概是这样，在一个for循环里对另一个函数进行调用

```
pragma solidity ^0.4.0;

contract test2{

    function g()private returns(uint){
        return 1;
    }


    function f()public returns(uint){
        uint i = 0;
        uint sum = 0;
        for (;i < 5;i+=1)
            sum += g();
    }

}
```

得到cfg如下图所示。此时看cfg，会有两个问题：

* 图中会有一个环，这个环应当被压缩为一个点。但是如果只看同一个函数内的点的话，并不能分析出这个环，所以说需要添加一条辅助的边（其实这就是沈学长说的fall边，ethersolve没有给出而已）
* 从起始offset为108的block开始，做dfs，只走函数内的点，直到offset为149的点结束。此时如果没有蓝色的边的话，就不能找到offset为135的块。

![](D:\Projects\iEvmOpt\pics\1.png)

解决办法也很简单。在做完所有的jump边的匹配之后，给它们的调用者加上一条辅助边即可。再做完这一步之后，再去寻找每个函数内的节点，以及环的处理。

###### 2.环形函数调用链(会终止) (已解决，见3)

代码大概是这样的：(f->g->h->f.......，但是该链会终止)

```
pragma solidity ^0.4.0;

contract test2{

    function g(uint x)private returns(uint){
        return h(x - 1);
    }

    function h(uint x)private returns(uint){
        if (x > 10)
            return f(x - 1);
        else 
            return 0;
    }

    function f(uint x)public returns(uint){
        return g(x - 1);
    }

}
```

编译得到的cfg如下。我尝试对其使用该算法，结果发现起始offset为142的block会被归类为两个不同的函数（看颜色，第一个函数是红的，第二个函数是蓝的）

![](D:\Projects\iEvmOpt\pics\2.png)

解决办法暂时有两个想法：

1. 如果发现同一个block被标记为两个函数，则取其中包含block数量更多的那个函数（寻找两个集合中较大者，前提是他们之间必须是包含关系）
2. 如果两个集合之间不是包含关系（我也没有找到相关的例子），则完全不能被优化，将他们标记为unsolve，后续做路径搜索的时候，不走unsolve节点。

###### 3.函数调用链必然会产生的问题

一旦函数调用链的长度大于2，必然会产生2中的问题。解决办法很简单，我们需要再加一条假设，它包含这两点：

* 任何函数调用的起始边，必然是伴随这样两条指令产生的：`PUSH 返回地址;JUMP`
* 任何函数调用的返回边，必然不是这样的结构：`PUSH 返回地址;JUMP`。

这样一来，我们就能确定哪些边有可能是起始边，哪些边必然不是起始边。这样便能排除错误的情况。



